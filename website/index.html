<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <link rel="stylesheet" href="stylesheets/screen.css" type="text/css" media="screen" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
      Clevic
  </title>
<style>

</style>
  <script type="text/javascript">
    window.onload = function() {
      settings = {
          tl: { radius: 10 },
          tr: { radius: 10 },
          bl: { radius: 10 },
          br: { radius: 10 },
          antiAlias: true,
          autoPad: true,
          validTags: ["div"]
      }
    }
  </script>
</head>
<body>

<div id="main">
	<h1>Clevic</h1>
	<p><a href="rdoc">RDoc</a> | <a href="http://rubyforge.org/projects/clevic/">Rubyforge Project</a></p>
<p>Clevic is a toolkit for building GUIs database tables with useful functionality.<br />
It works with Qt and ActiveRecord. In the works are Jruby with Swing for the <span class="caps">GUI</span><br />
and Sequel for the <span class="caps">ORM</span>. An interesting side-effect of this will be that<br />
building form-style GUIs will be possible.</p>
<p>Screenshot of a fully defined UI with the foreign-key dropdown in place.<br />
Tabs contain the two tables.</p>
<p>See <a href="rdoc">RDoc</a> for feature list.<br />
See <a href="rdoc/Clevic/ModelBuilder.html">ModelBuilder</a> for how to define views.</p>
<p><img src="screenshot.png" title="Screenshot" alt="Screenshot" /></p>
<p>Code for minimal UI definition. Clevic will create a fairly sensible<br />
UI from the DB metadata.</p>
<pre><code>
require 'clevic.rb'

# see sql/accounts.sql for schema

# db connection
Clevic::DbOptions.connect do
  database 'accounts_test'
  adapter :postgresql
  username 'accounts'
end

# minimal definition to get combo boxes to show up
class Entry &lt; ActiveRecord::Base
  include Clevic::Record
  belongs_to :debit, :class_name =&gt; 'Account', :foreign_key =&gt; 'debit_id'
  belongs_to :credit, :class_name =&gt; 'Account', :foreign_key =&gt; 'credit_id'
end

# minimal definition to get sensible values in combo boxes
class Account &lt; ActiveRecord::Base
  include Clevic::Record
  def to_s; name; end
end

</code></pre>
<p>Code for a full definition. The Entry model has some code to<br />
update the credit and debit fields when the new item description<br />
is found in the table.</p>
<pre><code>
require 'clevic.rb'

# db connection
Clevic::DbOptions.connect( $options ) do
  # use a different db for testing, so real data doesn't get broken.
  if options[:database].nil? || options[:database].empty?
    database( debug? ? :accounts_test : :accounts )
  else
    database options[:database]
  end
  # for AR
  #~ adapter :postgresql
  # for Sequel
  adapter :postgres
  username options[:username].blank? ? 'accounts' : options[:username]
end

class Entry &lt; Sequel::Model
  belongs_to :debit, :class_name =&gt; 'Account', :foreign_key =&gt; 'debit_id'
  belongs_to :credit, :class_name =&gt; 'Account', :foreign_key =&gt; 'credit_id'
  
  include Clevic::Record
  
  define_ui do
    plain       :date, :sample =&gt; '88-WWW-99'
    distinct    :description do |f|
      f.conditions "now() - date &lt;= '1 year'"
      f.sample( 'm' * 26 )
      f.notify_data_changed = lambda do |entity_view, table_view, model_index|
        if model_index.entity.credit.nil? &amp;&amp; model_index.entity.debit.nil?
          entity_view.update_from_description( model_index )
          
          # move edit cursor to amount field
          table_view.selection_model.clear
          table_view.override_next_index( model_index.choppy( :column =&gt; :amount ) )
        end
      end
    end
    relational  :debit, :display =&gt; 'name', :conditions =&gt; 'active = true', :order =&gt; 'lower(name)', :sample =&gt; 'Leilani Member Loan'
    relational  :credit, :display =&gt; 'name', :conditions =&gt; 'active = true', :order =&gt; 'lower(name)', :sample =&gt; 'Leilani Member Loan'
    plain       :amount, :sample =&gt; 999999.99
    distinct    :category
    plain       :cheque_number
    plain       :active, :sample =&gt; 'WW'
    plain       :vat, :label =&gt; 'VAT', :sample =&gt; 'WW', :tooltip =&gt; 'Does this include VAT?'
    
    records     :order =&gt; 'date, id'
  end
  
  # Copy the values for the credit and debit fields
  # from the previous similar entry with a similar description
  def self.update_from_description( current_index )
    return if current_index.attribute_value.nil?
    # most recent entry, ordered in reverse
    similar = self.adaptor.find(
      :first,
      :conditions =&gt; ["#{current_index.attribute} = ?", current_index.attribute_value],
      :order =&gt; 'date desc'
    )
    if similar != nil
      # set the values
      current_index.entity.debit = similar.debit
      current_index.entity.credit = similar.credit
      current_index.entity.category = similar.category
      
      # emit signal to that whole row has changed
      current_index.model.data_changed do |change|
        change.top_left = current_index.choppy( :column =&gt; 0 )
        change.bottom_right = current_index.choppy( :column =&gt; current_index.model.column_count - 1 )
      end
    end
  end
end

class Account &lt; Sequel::Model
  has_many :debits, :class_name =&gt; 'Entry', :foreign_key =&gt; 'debit_id'
  has_many :credits, :class_name =&gt; 'Entry', :foreign_key =&gt; 'credit_id'
  
  include Clevic::Record
  
  # define how fields are displayed
  define_ui do
    plain       :name
    restricted  :vat, :label =&gt; 'VAT', :set =&gt; %w{ yes no all }
    restricted  :account_type, :set =&gt; %w{Account Asset Assets Expenses Income Liability Opening Balance Personal Tax VAT}
    plain       :pastel_number, :alignment =&gt; Qt::AlignRight, :label =&gt; 'Pastel'
    plain       :fringe, :format =&gt; "%.1f"
    plain       :active
    
    records  :order =&gt; 'name,account_type'
  end
end

</code></pre>
</div>

<!-- insert site tracking codes here, like Google Urchin -->

</body>
</html>
