#! /usr/bin/ruby

require 'pathname'

require 'clevic/browser.rb'
require 'clevic/db_options.rb'
require 'optparse'
require 'active_support'

$options = {}
oparser = OptionParser.new
oparser.banner = <<BANNER
Usage: #{File.basename($0)} [options] model_definition_file

model_definition_file, \#{model_definition_file}_models.rb will be searched for.

Options are:
BANNER
oparser.separator ''

oparser.on( '-H', '--host HOST', 'RDBMS host', String ) { |o| $options[:host] = o }
oparser.on( '-u', '--user USERNAME', String ) { |o| $options[:username] = o }
oparser.on( '-p', '--pass PASSWORD', String ) { |o| $options[:password] = o }
oparser.on( '-P', '--profile PROFILE', String ) { |o| $options[:profile] = o }
oparser.on( '-t', '--table TABLE', 'Table to display', String ) { |o| $options[:table] = o }
oparser.on( '-d', '--database DATABASE', 'Database name', String ) { |o| $options[:database] = o }
oparser.on( '-D', '--debug' ) { |o| $options[:debug] = true }
oparser.on( '-v', '--verbose' ) { |o| $options[:verbose] = true }
oparser.on( '-h', '-?', '--help' ) do |o|
  puts oparser.to_s
  exit( 1 )
end

args = oparser.parse( ARGV )

if $options[:debug]
  require 'pp'
  pp $options
end

unless $options[:verbose]
  # turn off "Object#type deprecated" messages
  # and anything else output by rb_warn
  $VERBOSE = nil
end

class Pathname
  # require this pathname if it exists
  def require_if_exists
    require realpath.to_s if exist?
  end

  # just for fun, really
  alias_method :/, :+
end

def load_rails_models( root, config, models )
  # initialize Rails
  load config / 'environment.rb'
  require 'initializer.rb'
  Rails::Initializer.run do |config|
    config.frameworks -= [ :action_mailer, :action_pack, :active_resource ]
  end
  
  # load lib/ files for the rails project
  $: << ( root / 'lib' ).realpath.to_s
  ( root / 'lib' ).children.each do |filename|
    load filename if filename.file?
  end

  # include Dirty if it isn't already
  begin
    ActiveRecord::Dirty
  rescue NameError
    ActiveRecord::Base.send(:include, ActiveRecord::Dirty)
  end
  
  # load models
  models.find do |dir_entry|
    # don't load directory entries
    next unless dir_entry.file?
    # only load .rb files
    next unless dir_entry.basename.to_s =~ /\.rb$/
    begin
      load dir_entry
    rescue Exception => e
      puts "Error loading #{filename.basename.to_s}: #{e.message.inspect}"
      puts e.backtrace
    end
  end
end

def load_single_model_file( pathname )
  ( pathname + '.rb' ).require_if_exists
  pathname.require_if_exists
  ( pathname + '_models' ).require_if_exists
  ( pathname + '_models.rb' ).require_if_exists
end

def load_models( pathname )
  if pathname.directory?
    config = pathname / 'config'
    app = pathname / 'app'
    models = app / 'models'
    # check if this is a Rails directory
    if config.exist? && app.exist? && models.exist?
      # this is probably a Rails project"
      load_rails_models( pathname, config, models )
    end
  else
    # assume we have a single file, and try some variations
    load_single_model_file( pathname )
  end
end

# load model files
raise "no model definition file specified" if args.empty?
args.each { |arg| load_models( Pathname.new( arg ) ) }

app = Qt::Application.new( args )

# show UI
main_window = Qt::MainWindow.new
browser = Clevic::Browser.new( main_window )
# this must come after Clevic::Browser.new
main_window.show
# make sure any partially edited records are saved when the window is closed
app.connect( SIGNAL('lastWindowClosed()') ) { browser.save_all }
begin
  app.exec
rescue
  puts $!.message
  puts $!.backtrace
end
