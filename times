#! /usr/bin/ruby

require 'entry_table_view.rb'

# require AR
require 'rubygems'
require 'active_record'
require 'active_record/dirty.rb'

require 'optparse'

options = {}
oparser = OptionParser.new
oparser.on( '-h', '--host HOST', 'RDBMS host', String ) { |o| options[:host] = o }
oparser.on( '-u', '--user USERNAME', String ) { |o| options[:user] = o }
oparser.on( '-p', '--pass PASSWORD', String ) { |o| options[:password] = o }
oparser.on( '-t', '--table TABLE', 'Table to display', String ) { |o| options[:table] = o }
oparser.on( '-d', '--database DATABASE', 'Database name', String ) { |o| options[:database] = o }
oparser.on( '-D', '-v', '--debug' ) { |o| options[:debug] = true }
oparser.on( '-h', '-?', '--help' ) do |o|
  puts oparser.to_s
  exit( 0 )
end

args = oparser.parse( ARGV )

if args.size > 0
  options[:table] = args.shift
end

# Qt init. MUST come after options parsing, or Qt eats the options
app = Qt::Application.new( args )

if options[:debug]
  puts options.inspect
  puts args.inspect
  exit( 0 )
end

# set up defaults
options[:adapter]  ||= 'postgresql'
options[:database] ||= 'times'
options[:host] ||= 'localhost'
options[:username] ||= 'panic'
options[:password] ||= ''
options[:table] ||= 'entries'

# connect to the database
ActiveRecord::Base.establish_connection( options )

puts "using database #{ActiveRecord::Base.connection.raw_connection.db}"

# model definitions
class Entry < ActiveRecord::Base
  include ActiveRecord::Dirty
  belongs_to :invoice
  belongs_to :activity
  belongs_to :project
end

class Project < ActiveRecord::Base
  include ActiveRecord::Dirty
  has_many :entries
end

class Activity < ActiveRecord::Base
  include ActiveRecord::Dirty
  has_many :entries
end

class Invoice < ActiveRecord::Base
  include ActiveRecord::Dirty
  has_many :entries
end

def entries
  EntryTableView.new( Entry ).create_model do |t|
    t.plain       :date, :sample => '28-Dec-08'
    t.relational  :invoice, 'invoice_number', :sample => 'WWW000', :conditions => "status = 'not sent'", :order => 'invoice_number'
    t.relational  :project, 'project', :sample => 'Some Project', :conditions => 'active = true', :order => 'lower(project)'
    t.plain       :start, :sample => '00:00'
    t.plain       :end, :sample => '00:00'
    t.plain       :description, :sample => 'This is a long string designed to hold lots of data and description'
    t.relational  :activity, 'activity', :order => 'lower(activity)', :sample => 'Troubleshooting'
    t.distinct    :module, :sample => 'Doing Stuff'
    t.plain       :charge, :sample => 'Charge'
    t.distinct    :person, :sample => 'Leilani'
    
    t.collection = Entry.find( :all, :order => 'date, start, id' )
  end
end

def invoices
  EntryTableView.new( Invoice, nil ).create_model do |t|
    t.plain :date
    t.plain :client
    t.plain :invoice_number
    t.distinct :status
    t.plain :billing
    t.plain :quote_date
    t.plain :quote_amount
    t.plain :description
    
    t.collection = Invoice.find( :all, :order => 'invoice_number' )
  end
end

def projects
  EntryTableView.new( Project, nil ).create_model do |t|
    t.plain :project
    t.plain :description
    t.plain :client
    t.plain :rate
    t.plain :active
    
    t.collection = Project.find( :all, :order => 'id' )
  end
end

# must be one of the preceding function calls, or the eval will fail
table = eval( "#{options[:table]}()" )

table.minimum_width = 600
table.show

begin
  app.exec
rescue Exception => e
  puts e.backtrace.join( "\n" )
  puts e.message
end
